# DON'T! I'M NOT FINISHED!

%{
#
# cs-parser.jay: The Parser for the C# compiler
#
# Author: Miguel de Icaza (miguel@gnu.org)
#
# Licensed under the terms of the GNU GPL
#
# (C) 2001 Ximian, Inc (http:#www.ximian.com)
#
# TODO:
#   (1) Get rid of the *Collections.cs, that is an idea I took from System.CodeDOM
#       And come to think of it, it is not that great, it duplicates a lot of code
#       for something which is not really needed.  We still have piles of typecasts
#       anwyays (due to the nature of the stack being a collection of Objects).
#
#   (2) Figure out why error productions dont work.  `type-declaration' is a
#       great spot to put an `error' because you can reproduce it with this input:
#	 "public X { }"
#
#   (3) Move Modifier checking from each object into the parser itself, that will
#       get rid of the global "error" symbol that we use now to report errors. 
#       We still need to pass a pointer to the tree.ErrorHandler, but that is a 
#	 separate problem
#

%{
%}

%token EOF
%token NONE   /* This token is never returned by our lexer */
%token ERROR		# This is used not by the parser, but by the tokenizer.
			# do not remove.

/*
 *These are the C# keywords
 */
%token ABSTRACT	
%token AS
%token ADD
%token BASE	
%token BOOL	
%token BREAK	
%token BYTE	
%token CASE	
%token CATCH	
%token CHAR	
%token CHECKED	
%token CLASS	
%token CONST	
%token CONTINUE	
%token DECIMAL	
%token DEFAULT	
%token DELEGATE	
%token DO	
%token DOUBLE	
%token ELSE	
%token ENUM	
%token EVENT	
%token EXPLICIT	
%token EXTERN	
%token FALSE	
%token FINALLY	
%token FIXED	
%token FLOAT	
%token FOR	
%token FOREACH	
%token GOTO	
%token IF	
%token IMPLICIT	
%token IN	
%token INT	
%token INTERFACE
%token INTERNAL	
%token IS	
%token LOCK	
%token LONG	
%token NAMESPACE
%token NEW	
%token NULL	
%token OBJECT	
%token OPERATOR	
%token OUT	
%token OVERRIDE	
%token PARAMS	
%token PRIVATE	
%token PROTECTED
%token PUBLIC	
%token READONLY	
%token REF	
%token RETURN	
%token REMOVE
%token SBYTE	
%token SEALED	
%token SHORT	
%token SIZEOF	
%token STATIC	
%token STRING	
%token STRUCT	
%token SWITCH	
%token THIS	
%token THROW	
%token TRUE	
%token TRY	
%token TYPEOF	
%token UINT	
%token ULONG	
%token UNCHECKED
%token UNSAFE	
%token USHORT	
%token USING	
%token VIRTUAL	
%token VOID	
%token WHILE	

%token IDENTIFIER

/* Add precedence rules to solve dangling else s/r conflict */
%nonassoc IF
%nonassoc ELSE

%start compilation_unit
/*%start namespace_declaration */
%%

compilation_unit
	: opt_using_directives opt_attributes opt_namespace_member_declarations 
	  EOF
	  {
		# At some point check that using only comes *before* any namespaces
	  }
	;

using_directives
	: using_directive 
	| using_directives using_directive 
	;

using_directive
	: using_alias_directive
	| using_namespace_directive
	;

using_alias_directive
	: USING IDENTIFIER '=' 
	  namespace_or_type_name ';' {
	  }
	;

using_namespace_directive
	: USING namespace_name ';' 
	  {
		current_namespace.Using ((string) $2);
          }
	;

namespace_declarations
	: namespace_declaration
	| namespace_declarations namespace_declaration
;

namespace_declaration
	: NAMESPACE qualified_identifier 
	  {
		current_namespace = new Namespace (current_namespace, (string) $2); 
	  } 
	  namespace_body opt_semicolon
	  { 
		current_namespace = current_namespace.Parent;
	  }
	;

opt_semicolon
	: /* empty */
	| ';'
	;

opt_comma
	: /* empty */
	| ','
	;

qualified_identifier
	: IDENTIFIER
	| qualified_identifier '.' IDENTIFIER { 
	    $$ = (($1).ToString ()) + "." + ($3.ToString ()); }
	;


namespace_name
	: namespace_or_type_name
	;

namespace_body
	: '{'
	  opt_using_directives
	  opt_namespace_member_declarations
	  '}' {
	  }
	;

opt_using_directives
	: /* empty */
	| using_directives
	;

opt_namespace_member_declarations
	: /* empty */
	| namespace_member_declarations
	;

namespace_member_declarations
	: namespace_member_declaration
	| namespace_member_declarations namespace_member_declaration
	;

namespace_member_declaration
	: type_declaration
	  {
		int mod_flags = 0;
		string name = "";

		if ($1 is Class){
			Class c = (Class) $1;
			mod_flags = c.ModFlags;
			name = c.Name;
		} else if ($1 is Struct){
			Struct s = (Struct) $1;
			mod_flags = s.ModFlags;
			name = s.Name;
		} else
			break;

		#
		# We remove this error until we can 
		#if ((mod_flags & (Modifiers.PRIVATE|Modifiers.PROTECTED)) != 0){
		#	error (1527, "Namespace elements cant be explicitly " +
		#	             "declared private or protected in `" + name + "'");
		#}
	  }
	| namespace_declaration
	;

type_declaration
	: class_declaration		
	| struct_declaration		
	| interface_declaration		
	| enum_declaration		
	| delegate_declaration		# finishme
	;

#
# Attributes 17.2
#
opt_attributes
	: /* empty */
	| attributes
	;

attributes
	: attribute_sections
	;

attribute_sections
	: attribute_section
	| attribute_sections attribute_section
	;

attribute_section
	: '['
	  opt_attribute_target_specifier attribute_list 
	  /* FIXME: opt_comma */ 
	  ']' 
	;

opt_attribute_target_specifier
	: /* empty */
	| attribute_target_specifier
	;

attribute_target_specifier
	: attribute_target ':'
	;

attribute_target
	: IDENTIFIER  { 
	     # if (Collection.Contains ($$))... FIXME
	     note  ("Allows: assembly, field, method, module, param, property, type"); 
	}
	| EVENT
	| RETURN 
	;

attribute_list
	: attribute
	| attribute_list ',' attribute
	;

attribute
	: attribute_name
	| opt_attribute_arguments
	;

attribute_name
	: type_name		{ /* reserved attribute name or identifier: 17.4 */ }
	;

opt_attribute_arguments
	: /* empty */
	| '(' attribute_arguments ')'
	;

attribute_arguments
	: expression
	| attribute_arguments ',' expression
	;

/*
opt_dimension_separators
	:
	| dimension_separators
	;

dimension_separators
	: ',' 
	| dimension_separators ',' 
	;
*/

class_body
	:  '{' opt_class_member_declarations '}'
	;

opt_class_member_declarations
	: /* empty */
	| class_member_declarations
	;

class_member_declarations
	: class_member_declaration
	| class_member_declarations 
	  class_member_declaration
	;

class_member_declaration
	: constant_declaration			# done
	| field_declaration			# done
	| method_declaration			# done
	| property_declaration			# done
	| event_declaration			# finishme
	| indexer_declaration			# finishme
	| operator_declaration			# finishme
	| constructor_declaration		# done
	| destructor_declaration		# done
	| type_declaration
	;

struct_declaration
	: opt_attributes
	  opt_modifiers
	  STRUCT IDENTIFIER
	  { 
		Struct new_struct;
		string full_struct_name = MakeName ((string) $4);

		new_struct = new Struct (current_container, full_struct_name, (int) $2);
		current_container = new_struct;
		current_container.Namespace = current_namespace;
		tree.RecordType (full_class_name, new_struct);
	  }
	  opt_struct_interfaces
	  struct_body
	  opt_semicolon
	  {
		Struct new_struct = (Struct) current_container;

		current_container = current_container.Parent;
		CheckDef (current_container.AddStruct (new_struct), new_struct.Name);
		$$ = new_struct;
	  }
	;

opt_struct_interfaces
	: /* empty */
	| struct_interfaces
	;

struct_interfaces
	: struct_interface
	| struct_interfaces struct_interface
	; 

struct_interface
	: ':' type_list
	;

struct_body
	: '{' opt_struct_member_declarations '}'
	;

opt_struct_member_declarations
	: /* empty */
	| struct_member_declarations
	;

struct_member_declarations
	: struct_member_declaration
	| struct_member_declarations struct_member_declaration
	;

struct_member_declaration
	: constant_declaration
	| field_declaration
	| method_declaration
	| property_declaration
	| event_declaration
	| indexer_declaration
	| operator_declaration
	| constructor_declaration
	| type_declaration
	;

constant_declaration
	: opt_attributes 
	  opt_modifiers
	  CONST
	  type
	  constant_declarators
	  ';'
	  { 
		Modifiers.Check (Constant.AllowedModifiers, (int) $2, Modifiers.PRIVATE);

		foreach (DictionaryEntry constant in (ArrayList) $5){
			Constant c = new Constant (
				(TypeRef) $4, (string) constant.Key, 
				(Expression) constant.Value);

			CheckDef (current_container.AddConstant (c), c.Name);
		}
	  }
	;

constant_declarators
	: constant_declarator 
	  {
		ArrayList constants = new ArrayList ();
		constants.Add ($1);
		$$ = constants;
	  }
	| constant_declarators ',' constant_declarator
	  {
		ArrayList constants = (ArrayList) $1;

		constants.Add ($3);
	  }
	;

constant_declarator
	: IDENTIFIER '=' constant_expression {
		$$ = new DictionaryEntry ($1, $3);
	  }
	;

field_declaration
	: opt_attributes
	  opt_modifiers
	  type 
	  variable_declarators
	  ';'
	{ 
		TypeRef typeref = (TypeRef) $3;
		int mod = (int) $2;

		foreach (VariableDeclaration var in (ArrayList) $4){
			Field field = new Field (typeref, mod, var.identifier, 
						 var.expression_or_array_initializer);

			CheckDef (current_container.AddField (field), field.Name);
		}
	}

	;

variable_declarators
	: variable_declarator 
	  {
		ArrayList decl = new ArrayList ();
		$$ = decl;
		decl.Add ($1);
	  }
	| variable_declarators ',' variable_declarator
	  {
		ArrayList decls = (ArrayList) $1;
		decls.Add ($3);
		$$ = $1;
	  }
	;

variable_declarator
	: IDENTIFIER '=' variable_initializer
	  {
		$$ = new VariableDeclaration ((string) $1, $3);
	  }
	| IDENTIFIER
	  {
		$$ = new VariableDeclaration ((string) $1, null);
	  }
	;

variable_initializer
	: expression
	| array_initializer
	;

method_declaration
	: method_header
	  method_body
	  {
		Method method = (Method) $1;

		method.Block = (Block) $2;
		CheckDef (current_container.AddMethod (method), method.Name);

		current_local_parameters = null;
	  }
	;

method_header
	: opt_attributes
	  opt_modifiers
	  type
	  member_name
	  '(' opt_formal_parameter_list ')' 
	  {
		Method method = new Method ((TypeRef) $3, (int) $2, (string) $4, (Parameters) $6);

		current_local_parameters = (Parameters) $6;

		$$ = method;
	  }
	| opt_attributes
	  opt_modifiers
	  VOID
	  member_name
	  '(' opt_formal_parameter_list ')' 
	  {
		Method method = new Method (type ("void"), (int) $2, (string) $4, (Parameters) $6);

		current_local_parameters = (Parameters) $6;
		$$ = method;
	  }
	;

method_body
	: block
	| ';'		{ $$ = null; }
	;

opt_formal_parameter_list
	: /* empty */			{ $$ = new Parameters (null, null); }
	| formal_parameter_list
	;

formal_parameter_list
	: fixed_parameters		
	  { 
	  	$$ = new Parameters ((ParameterCollection) $1, null); 
	  } 
	| fixed_parameters ',' parameter_array
	  {
		$$ = new Parameters ((ParameterCollection) $1, (Parameter) $3); 
	  }
	| parameter_array 
	  {
		$$ = new Parameters (null, (Parameter) $1);
	  }
	;

fixed_parameters
	: fixed_parameter	
	  {
		ParameterCollection pars = new ParameterCollection ();
		pars.Add ((Parameter) $1);
		$$ = pars;
	  }
	| fixed_parameters ',' fixed_parameter
	  {
		ParameterCollection pars = (ParameterCollection) $1;
		pars.Add ((Parameter) $3);
		$$ = $1;
	  }
	;

fixed_parameter
	: opt_attributes
	  opt_parameter_modifier
	  type
	  IDENTIFIER
	  {
		$$ = new Parameter ((TypeRef) $3, (string) $4, (Parameter.Modifier) $2);
	  }
	;

opt_parameter_modifier
	: /* empty */		{ $$ = Parameter.Modifier.NONE; }
	| parameter_modifier
	;

parameter_modifier
	: REF			{ $$ = Parameter.Modifier.REF; }
	| OUT			{ $$ = Parameter.Modifier.OUT; }
	;

parameter_array
	: opt_attributes PARAMS type IDENTIFIER
	  { 
		$$ = new Parameter ((TypeRef) $3, (string) $4, Parameter.Modifier.PARAMS);
		note ("type must be a single-dimension array type"); 
	  }
	;

member_name 
	: IDENTIFIER { $$ = $1.ToString (); }
	| interface_type '.' IDENTIFIER { $$ = $1.ToString () + "." + $3.ToString (); }
	;

property_declaration
	: opt_attributes
	  opt_modifiers
	  type member_name
	  '{' 
	  {
		Parameter implicit_value_parameter;
		implicit_value_parameter = new Parameter ((TypeRef) $3, "value", Parameter.Modifier.NONE);

		lexer.properties = true;
		
		implicit_value_parameters = new ParameterCollection ();
		implicit_value_parameters.Add (implicit_value_parameter);
	  }
	  accessor_declarations 
	  {
		lexer.properties = false;
	  }
	  '}'
	  { 
		Property prop;
		DictionaryEntry pair = (DictionaryEntry) $7;
		Block get_block = null;
		Block set_block = null;

		if (pair.Key != null)
			get_block = (Block) pair.Key;
		if (pair.Value != null)
			set_block = (Block) pair.Value;

		prop = new Property ((TypeRef) $3, (string) $4, (int) $2, get_block, set_block);
		
		CheckDef (current_container.AddProperty (prop), prop.Name);
		implicit_value_parameters = null;
	  }
	;

accessor_declarations
	: get_accessor_declaration opt_set_accessor_declaration
	  { 
		$$ = new DictionaryEntry ($1, $2);
	  }
	| set_accessor_declaration opt_get_accessor_declaration
	  {
		$$ = new DictionaryEntry ($2, $1);
	  }
	;

opt_get_accessor_declaration
	: /* empty */			{ $$ = null; }
	| get_accessor_declaration
	;

opt_set_accessor_declaration
	: /* empty */			{ $$ = null; }
	| set_accessor_declaration
	;

get_accessor_declaration
	: opt_attributes 'get' accessor_body 
	  {
		$$ = $3;
	  }
	;

set_accessor_declaration
	: opt_attributes 'set' 
	  { 
		current_local_parameters = new Parameters (implicit_value_parameters, null);
	  }
	  accessor_body
	  {
		$$ = $4;
		current_local_parameters = null;
	  }
	;

accessor_body
	: block 
	| ';'		{ $$ = new Block (null); }
	;

interface_declaration
	: opt_attributes
	  opt_modifiers
	  INTERFACE IDENTIFIER
	  {
		Interface new_interface;
		string full_interface_name = MakeName ((string) $4);

		new_interface = new Interface (current_container, full_interface_name, (int) $2);
		if (current_interface != null)
			error (-2, "Internal compiler error: interface inside interface");
		current_interface = new_interface;
		tree.RecordType (full_class_name, new_interface);
	  }
	  opt_interface_base
	  interface_body
	  { 
		Interface new_interface = (Interface) current_interface;

		if ($6 != null)
			new_interface.Bases = (ArrayList) $6;

		current_interface = null;
		CheckDef (current_container.AddInterface (new_interface), new_interface.Name);
	  }
	;

opt_interface_base
	: /* empty */			  { $$ = null; }
	| interface_base
	;

interface_base
	: ':' interface_type_list	  { $$ = $2; }
	;

interface_type_list
	: interface_type
	  {
		ArrayList interfaces = new ArrayList ();

		interfaces.Add ($1);
	  }
	| interface_type_list ',' interface_type
	  {
		ArrayList interfaces = (ArrayList) $1;
		interfaces.Add ($3);
		$$ = interfaces;
	  }
	;

interface_body
	: '{'
	  opt_interface_member_declarations
	  '}'
	;

opt_interface_member_declarations
	: /* empty */
	| interface_member_declarations
	;

interface_member_declarations
	: interface_member_declaration
	| interface_member_declarations interface_member_declaration
	;

interface_member_declaration
	: interface_method_declaration		
	  { 
		InterfaceMethod m = (InterfaceMethod) $1;

		CheckDef (current_interface.AddMethod (m), m.Name);
	  }
	| interface_property_declaration	
	  { 
		InterfaceProperty p = (InterfaceProperty) $1;

		CheckDef (current_interface.AddProperty (p), p.Name);
          }
	| interface_event_declaration 
          { 
		InterfaceEvent e = (InterfaceEvent) $1;

		CheckDef (current_interface.AddEvent (e), e.Name);
	  }
	| interface_indexer_declaration
	  { 
		InterfaceIndexer i = (InterfaceIndexer) $1;

		CheckDef (current_interface.AddIndexer (i), "indexer");
	  }
	;

opt_new
	: /* empty */	{ $$ = false; }
	| NEW		{ $$ = true; }
	;

interface_method_declaration
	: opt_attributes opt_new type IDENTIFIER 
	  '(' opt_formal_parameter_list ')'
	  ';'
	  {
		$$ = new InterfaceMethod ((TypeRef) $3, (string) $4, (bool) $2, (Parameters) $6);
	  }
	| opt_attributes opt_new VOID IDENTIFIER 
	  '(' opt_formal_parameter_list ')'
	  ';'
	  {
		$$ = new InterfaceMethod (type ("void"), (string) $4, (bool) $2, (Parameters) $6);
	  }
	;

interface_property_declaration
	: opt_attributes
	  opt_new
	  type IDENTIFIER 
	  '{' 
	  { lexer.properties = true; }
	  interface_accesors 
	  { lexer.properties = false; }
	  '}'
	  {
	        int gs = (int) $7;

		$$ = new InterfaceProperty ((TypeRef) $3, (string) $4, (bool) $2, 
					    (gs & 1) == 1, (gs & 2) == 2);
	  }
	;

interface_accesors
	: opt_attributes 'get' ';'		{ $$ = 1; }
	| opt_attributes 'set' ';'		{ $$ = 2; }
	| opt_attributes 'get' ';' opt_attributes 'set' ';' 
	  { $$ = 3; }
	| opt_attributes 'set' ';' opt_attributes 'get' ';'
	  { $$ = 3; }
	;

interface_event_declaration
	: opt_attributes opt_new EVENT type IDENTIFIER ';'
	  {
		$$ = new InterfaceEvent ((TypeRef) $4, (string) $5, (bool) $2);
	  }
	;

interface_indexer_declaration 
	: opt_attributes opt_new type THIS 
	  '[' formal_parameter_list ']'
	  '{' 
	  { lexer.properties = true; }
	  interface_accesors 
	  { lexer.properties = false; }
	  '}'
	  {
		int a_flags = (int) $10;

	  	bool do_get = (a_flags & 1) == 1;
		bool do_set = (a_flags & 2) == 2;

		$$ = new InterfaceIndexer ((TypeRef) $3, (Parameters) $6, do_get, do_set, (bool) $2);
	  }
	;

operator_declaration
	: opt_attributes opt_modifiers operator_declarator block
	  {
		# FIXME: validate that opt_modifiers is exactly: PUBLIC and STATIC
	  }
	;

operator_declarator
	: type OPERATOR overloadable_operator 
	  '(' type IDENTIFIER ')'
	  {
		# FIXME: since reduce/reduce on this
	 	# rule, validate overloadable_operator is unary
	  }
	| type OPERATOR overloadable_operator
	  '(' 
		type IDENTIFIER ','
	  	type IDENTIFIER 
	  ')'
	  {
		# FIXME: because of the reduce/reduce on '+' and '-'
		# validate overloadable_operator is binary
	  }
	| conversion_operator_declarator
	;

overloadable_operator
# Unary operators:
	: '!'
	| '~'
	| '++'
	| '--'
	| TRUE
	| FALSE
# Unary and binary:
	| '+' 
	| '-'
# Binary:
	| '*' 
	| '/' 
	| '%' 
	| '&' 
	| '|' 
	| '^' 
	| '<<'
	| '>>'
	| '=='
	| '!='
	| '>'
	| '<'
	| '>='
	| '<='
	;

conversion_operator_declarator
	: IMPLICIT OPERATOR type '(' type IDENTIFIER ')'
	| EXPLICIT OPERATOR type '(' type IDENTIFIER ')'
	;

constructor_declaration
	: opt_attributes
	  opt_modifiers
	  constructor_declarator
	  block
	  { 
		Constructor c = (Constructor) $3;
		c.Block = (Block) $4;
		c.ModFlags = (int) $2;

		if ((c.ModFlags & Modifiers.STATIC) != 0){
			if ((c.ModFlags & Modifiers.Accessibility) != 0){
				error (515, "Access modifiers are not allowed on static constructors");
			}
		}
		CheckDef (current_container.AddConstructor (c), c.Name);

		current_local_parameters = null;
	  }
	;

constructor_declarator
	: IDENTIFIER 
	  '(' opt_formal_parameter_list ')' 
	  opt_constructor_initializer
	  {
		ConstructorInitializer i = null;

		if ($5 != null)
			i = (ConstructorInitializer) $5;

		$$ = new Constructor ((string) $1, (Parameters) $3, i);
	
		current_local_parameters = (Parameters) $3;
	  }
	;

opt_constructor_initializer
	: /* empty */			{ $$ = null; }
	| constructor_initializer
	;

constructor_initializer
	: ':' BASE '(' opt_argument_list ')'
	  {
		$$ = new ConstructorBaseInitializer ((ArrayList) $4);
	  }
	| ':' THIS '(' opt_argument_list ')'
	  {
		$$ = new ConstructorThisInitializer ((ArrayList) $4);
	  }
	;

destructor_declaration
	: opt_attributes '~' IDENTIFIER '(' ')' block
	  {
		Method d = new Method (type ("void"), 0, "Finalize", new Parameters (null, null));

		d.Block = (Block) $6;
		CheckDef (current_container.AddMethod (d), d.Name);
	  }
	;

event_declaration
	: opt_attributes
	  opt_modifiers
	  EVENT type variable_declarators ';'
	  { note ("validate that the flags only contain new public protected internal private static virtual sealed override abstract"); }
	| opt_attributes
	  opt_modifiers
	  EVENT type member_name 
	  '{' event_accesor_declarations '}' ';'
	  { note ("validate that the flags only contain new public protected internal private static virtual sealed override abstract"); }
	;

event_accesor_declarations
	: add_accessor_declaration remove_accessor_declaration
	| remove_accessor_declaration add_accessor_declaration
	;

add_accessor_declaration
	: opt_attributes ADD block
	;

remove_accessor_declaration
	: opt_attributes REMOVE block
	;

indexer_declaration
	: opt_attributes opt_modifiers indexer_declarator 
	  '{' accessor_declarations '}'
	  { 
		# The signature is computed from the signature of the indexer.  Look
	 	# at section 3.6 on the spec
		note ("verify modifiers are NEW PUBLIC PROTECTED INTERNAL PRIVATE VIRTUAL SEALED OVERRIDE ABSTRACT"); 
	  }
	;

indexer_declarator
	: type THIS '[' formal_parameter_list ']'
	| type interface_type '.' THIS '[' formal_parameter_list ']'
	;

enum_declaration
	: opt_attributes
	  opt_modifiers
	  ENUM IDENTIFIER
	  opt_enum_base
	  enum_body
	  opt_semicolon
	  { 
		string name = (string) $4;
		Enum e = new Enum ((TypeRef) $5, (int) $2, name);

		foreach (VariableDeclaration ev in (ArrayList) $6){
			CheckDef (
				e.AddEnum (
					ev.identifier, 
					(Expression) ev.expression_or_array_initializer),
				ev.identifier);
		}

		CheckDef (current_container.AddEnum (e), name);
	  }
	;

opt_enum_base
	: /* empty */			{ $$ = type ("System.Int32"); }
	| ':' integral_type		{ $$ = $2;   }
	;

enum_body
	: '{' opt_enum_member_declarations '}'
	  {
		$$ = $2;
	  }
	| '{' enum_member_declarations ',' '}'
	  {
		$$ = $2;
	  }
	;

opt_enum_member_declarations
	: /* empty */			{ $$ = new ArrayList (); }
	| enum_member_declarations      { $$ = $1; }
	;

enum_member_declarations
	: enum_member_declaration 
	  {
		ArrayList l = new ArrayList ();

		l.Add ($1);
		$$ = l;
	  }
	| enum_member_declarations ',' enum_member_declaration
	  {
		ArrayList l = (ArrayList) $1;

		l.Add ($3);

		$$ = l;
	  }
	;

enum_member_declaration
	: opt_attributes IDENTIFIER 
	  {
		$$ = new VariableDeclaration ((string) $2, null);
	  }
	| opt_attributes IDENTIFIER '=' expression
	  { 
		$$ = new VariableDeclaration ((string) $2, $4);
	  }
	;

delegate_declaration
	: opt_attributes
	  opt_modifiers
	  DELEGATE type	  
	  IDENTIFIER '(' 
	  formal_parameter_list
	  ')' 
	  ';'
	  { note ("validate that modifiers only contains NEW PUBLIC PROTECTED INTERNAL PRIVATE"); }
	;

type_name
	: namespace_or_type_name
	;

namespace_or_type_name
	: qualified_identifier
	;

/* 
 * Before you think of adding a return_type, notice that we have been
 * using two rules in the places where it matters (one rule using type
 * and another identical one that uses VOID as the return type).  This
 * gets rid of a shift/reduce couple
 */
type
	: type_name {  	/* class_type */
		/* 
	           This does interfaces, delegates, struct_types, class_types, 
	           parent classes, and more! 4.2 
	         */
		$$ = type ((string) $1); 
	  }
	| builtin_types
	| array_type
	;

type_list
	: type
	  {
		ArrayList types = new ArrayList ();

		types.Add ($1);
		$$ = types;
	  }
	| type_list type
	  {
		ArrayList types = new ArrayList ();
		types.Add ($2);
		$$ = types;
	  }
	;

/*
 * replaces all the productions for isolating the various
 * simple types, but we need this to reuse it easily in local_variable_type
 */
builtin_types
	: OBJECT	{ $$ = type ("System.Object"); }
	| STRING	{ $$ = type ("System.String"); }
	| BOOL		{ $$ = type ("System.Boolean"); }
	| DECIMAL	{ $$ = type ("System.Decimal"); }
	| FLOAT		{ $$ = type ("System.Single"); }
	| DOUBLE	{ $$ = type ("System.Double"); }
	| integral_type
	;

integral_type
	: SBYTE		{ $$ = type ("System.SByte"); }
	| BYTE		{ $$ = type ("System.Byte"); }
	| SHORT		{ $$ = type ("System.Int16"); }
	| USHORT	{ $$ = type ("System.UInt16"); }
	| INT		{ $$ = type ("System.Int32"); }
	| UINT		{ $$ = type ("System.UInt32"); }
	| LONG		{ $$ = type ("System.Int64"); }
	| ULONG		{ $$ = type ("System.UInt64"); }
	| CHAR		{ $$ = type ("System.Char"); }
	;

interface_type
	: type_name
	;

array_type
	: type rank_specifiers
	  {
		$$ = $1;
		# FIXME: We need to create a type for the nested thing.
	  }
	;

#
# Expressions, section 7.5
#
primary_expression
	: literal
	  {
		# 7.5.1: Literals
		
	  }
 
	| qualified_identifier
	  {
		string name = (string) $1;

		$$ = null;
		if (name.IndexOf ('.') == -1){
			#
			# we need to check against current_block not being null
			# as `expression' is allowed in argument_lists, which 
			# do not exist inside a block.  
			#
			if (current_block != null){
				if (current_block.IsVariableDefined (name))
					$$ = new LocalVariableReference (current_block, name);
			}
			if (($$ == null) && (current_local_parameters != null)){
				Parameter par = current_local_parameters.GetParameterByName (name);
				if (par != null)
					$$ = new ParameterReference (current_local_parameters, name);
			}
		}
		if ($$ == null)
			$$ = new SimpleName (name);
	  }
	| parenthesized_expression
	| member_access
	| invocation_expression
	| element_access
	| this_access
	| base_access
	| post_increment_expression
	| post_decrement_expression
	| new_expression
	| typeof_expression
	| sizeof_expression
	| checked_expression
	| unchecked_expression
	;

literal
	: boolean_literal
	| integer_literal
	| real_literal
	| 'character literal'     { $$ = new CharLiteral ((char) lexer.Value); }
	| 'string literal'        { $$ = new StringLiteral ((string) lexer.Value); }
	| NULL			{ $$ = new NullLiteral (); }
	;

real_literal
	: 'float literal'         { $$ = new FloatLiteral ((float) lexer.Value); }
	| 'double literal'        { $$ = new DoubleLiteral ((double) lexer.Value); }
	| 'decimal literal'       { $$ = new DecimalLiteral ((decimal) lexer.Value); }
	;

integer_literal
	: 'int literal'       { $$ = new IntLiteral ((Int32) lexer.Value); }
	;

boolean_literal
	: TRUE			{ $$ = new BoolLiteral (true); }
	| FALSE			{ $$ = new BoolLiteral (false); }
	;

parenthesized_expression
	: '(' expression ')'
	  { $$ = $2; }
	;

member_access
	: primary_expression '.' IDENTIFIER
	  {
		$$ = new MemberAccess ((Expression) $1, (string) $3);
	  }
	| predefined_type '.' IDENTIFIER
	  {
		$$ = new BuiltinTypeAccess ((TypeRef) $1, (string) $3);
	  }
	;

predefined_type
	: builtin_types
	;

invocation_expression
	: primary_expression '(' opt_argument_list ')'
	  {
		# FIXME:
		# if $1 is MethodGroup
		#	$$ = new Call ($1, $3);
		# else 
		# 	$$ = new DelegateCall ($1, $3);
		if ($1 == null)
			error (1, "THIS IS CRAZY");

		$$ = new Invocation ((Expression) $1, (ArrayList) $3);
	  }
	; 

opt_argument_list
	: /* empty */		{ $$ = new ArrayList (); }
	| argument_list
	;

argument_list
	: argument		
	  { 
		ArrayList list = new ArrayList ();
		list.Add ($1);
		$$ = list;
	  }
	| argument_list ',' argument
	  {
		ArrayList list = (ArrayList) $1;
		list.Add ($3);
		$$ = list;
	  }
	;

argument
	: expression
	  {
		$$ = new Argument ((Expression) $1, Argument.AType.Expression);
	  }
	| REF variable_reference 
	  { 
		$$ = new Argument ((Expression) $2, Argument.AType.Ref);
	  }
	| OUT variable_reference 
	  { 
		$$ = new Argument ((Expression) $2, Argument.AType.Out);
	  }
	;

variable_reference
	: expression { note ("section 5.4"); $$ = $1; }
	;

element_access
	: primary_expression '[' expression_list ']'	
	# finishme
	;

expression_list
	: expression
	| expression_list ',' expression
	;

this_access
	: THIS
	  {
		$$ = new This ();
	  }
	;

base_access
	: BASE '.' IDENTIFIER
	# finishme
	| BASE '[' expression_list ']'
	# finishme
	;

post_increment_expression
	: primary_expression '++'
	  {
		$$ = new Unary (Unary.Operator.PostIncrement, (Expression) $1);
	  }
	;

post_decrement_expression
	: primary_expression '--'
	  {
		$$ = new Unary (Unary.Operator.PostDecrement, (Expression) $1);
	  }
	;

new_expression
	: object_or_delegate_creation_expression
	| array_creation_expression
	;

object_or_delegate_creation_expression
	: NEW type '(' opt_argument_list ')'
	  {
		$$ = new New ((TypeRef) $2, (ArrayList) $4);
	  }
	;

array_creation_expression
	: NEW type '[' expression_list ']' 
	  opt_rank_specifier
	  opt_array_initializer
	# finishme
	;

opt_rank_specifier
	: /* empty */
	| rank_specifiers
	;

rank_specifiers
	: rank_specifier
	| rank_specifiers rank_specifier
	# finishme
	;

rank_specifier
	: '[' opt_dim_separators ']'
	# finishme
	;

opt_dim_separators
	: /* empty */
	| dim_separators
	# finishme
	;

dim_separators
	: ','
	| dim_separators ','
	# finishme
	;

opt_array_initializer
	: /* empty */
	| array_initializer
	;

array_initializer
	: '{' '}'
	| '{' variable_initializer_list '}'
	| '{' variable_initializer_list ',' '}'
	# finishme
	;

variable_initializer_list
	: variable_initializer
	| variable_initializer_list ',' variable_initializer
	# finishme
	;

typeof_expression
	: TYPEOF '(' type ')'
	  {
		$$ = new TypeOf ((TypeRef) $3);
	  }
	;

sizeof_expression
	: SIZEOF '(' type ')' { 
		$$ = new SizeOf ((TypeRef) $3);

		note ("Verify type is unmanaged"); 
		note ("if (5.8) builtin, yield constant expression");
	  }
	;

checked_expression
	: CHECKED '(' expression ')'
	;

unchecked_expression
	: UNCHECKED '(' expression ')'
	;

unary_expression
	: primary_expression
	| '+' unary_expression		{ 
	  	$$ = new Unary (Unary.Operator.Plus, (Expression) $2);
	  } 
	| '-' unary_expression 
	  { 
		$$ = new Unary (Unary.Operator.Minus, (Expression) $2);
	  }
	| '!' unary_expression 
	  {
		$$ = new Unary (Unary.Operator.Negate, (Expression) $2);
	  }
	| '~' unary_expression
	  {
		$$ = new Unary (Unary.Operator.BitComplement, (Expression) $2);
	  }
	| '*' unary_expression
	  {
		$$ = new Unary (Unary.Operator.Indirection, (Expression) $2);
	  }
	| '&' unary_expression
	  {
		$$ = new Unary (Unary.Operator.AddressOf, (Expression) $2);
	  }
	| pre_increment_expression
	| pre_decrement_expression 
        | cast_expression 
	/*
	 we can not do cast expressions at this level,
	 as there is an ambiguity.  Check "Cast Expressions" 7.6.8
	 for the recipe to handle this.
	 */
	;

pre_increment_expression
	: '++' unary_expression 
	  {
		$$ = new Unary (Unary.Operator.PreIncrement, (Expression) $2);
	  }
	;

pre_decrement_expression
	: '--' unary_expression 
	  {
		$$ = new Unary (Unary.Operator.PreDecrement, (Expression) $2);
	  }
	;

cast_expression
	/* FIXME: This is actually wrong, it should be `type' but that
	 * introduces a lot of {shift,reduce}/reduces
	 */
	: '(' qualified_identifier ')' unary_expression
	  {
		$$ = new Cast (type ((string) $2), (Expression) $4);
	  }
	| '(' builtin_types ')' unary_expression
	  {
		$$ = new Cast ((TypeRef) $2, (Expression) $4);
	  }
	;

multiplicative_expression
	: unary_expression
	| multiplicative_expression '*' unary_expression
	  {
		$$ = new Binary (Binary.Operator.Multiply, 
			         (Expression) $1, (Expression) $3);
	  }
	| multiplicative_expression '/' unary_expression
	  {
		$$ = new Binary (Binary.Operator.Divide, 
			         (Expression) $1, (Expression) $3);
	  }
	| multiplicative_expression '%' unary_expression 
	  {
		$$ = new Binary (Binary.Operator.Modulo, 
			         (Expression) $1, (Expression) $3);
	  }
	;

additive_expression
	: multiplicative_expression
	| additive_expression '+' multiplicative_expression 
	  {
		$$ = new Binary (Binary.Operator.Add, 
			         (Expression) $1, (Expression) $3);
	  }
	| additive_expression '-' multiplicative_expression
	  {
		$$ = new Binary (Binary.Operator.Substract, 
			         (Expression) $1, (Expression) $3);
	  }
	;

shift_expression
	: additive_expression
	| shift_expression '<<' additive_expression
	  {
		$$ = new Binary (Binary.Operator.ShiftLeft, 
			         (Expression) $1, (Expression) $3);
	  }
	| shift_expression '>>' additive_expression
	  {
		$$ = new Binary (Binary.Operator.ShiftRight, 
			         (Expression) $1, (Expression) $3);
	  }
	; 

relational_expression
	: shift_expression
	| relational_expression '<' shift_expression
	  {
		$$ = new Binary (Binary.Operator.LessThan, 
			         (Expression) $1, (Expression) $3);
	  }
	| relational_expression '>' shift_expression
	  {
		$$ = new Binary (Binary.Operator.GreatherThan, 
			         (Expression) $1, (Expression) $3);
	  }
	| relational_expression '<=' shift_expression
	  {
		$$ = new Binary (Binary.Operator.LessOrEqual, 
			         (Expression) $1, (Expression) $3);
	  }
	| relational_expression '>=' shift_expression
	  {
		$$ = new Binary (Binary.Operator.GreatherOrEqual, 
			         (Expression) $1, (Expression) $3);
	  }
	| relational_expression IS type
	  {
		$$ = new Probe (Probe.Operator.Is, 
			         (Expression) $1, (TypeRef) $3);
	  }
	| relational_expression AS type
	  {
		$$ = new Probe (Probe.Operator.As, 
			         (Expression) $1, (TypeRef) $3);
	  }
	;

equality_expression
	: relational_expression
	| equality_expression '==' relational_expression
	  {
		$$ = new Binary (Binary.Operator.Equal, 
			         (Expression) $1, (Expression) $3);
	  }
	| equality_expression '!=' relational_expression
	  {
		$$ = new Binary (Binary.Operator.NotEqual, 
			         (Expression) $1, (Expression) $3);
	  }
	; 

and_expression
	: equality_expression
	| and_expression '&' equality_expression
	  {
		$$ = new Binary (Binary.Operator.BitwiseAnd, 
			         (Expression) $1, (Expression) $3);
	  }
	;

exclusive_or_expression
	: and_expression
	| exclusive_or_expression '^' and_expression
	  {
		$$ = new Binary (Binary.Operator.ExclusiveOr, 
			         (Expression) $1, (Expression) $3);
	  }
	;

inclusive_or_expression
	: exclusive_or_expression
	| inclusive_or_expression '|' exclusive_or_expression
	  {
		$$ = new Binary (Binary.Operator.BitwiseOr, 
			         (Expression) $1, (Expression) $3);
	  }
	;

conditional_and_expression
	: inclusive_or_expression
	| conditional_and_expression '&&' inclusive_or_expression
	  {
		$$ = new Binary (Binary.Operator.LogicalAnd, 
			         (Expression) $1, (Expression) $3);
	  }
	;

conditional_or_expression
	: conditional_and_expression
	| conditional_or_expression '||' conditional_and_expression
	  {
		$$ = new Binary (Binary.Operator.LogicalOr, 
			         (Expression) $1, (Expression) $3);
	  }
	;

conditional_expression
	: conditional_or_expression
	| conditional_or_expression '?' expression ':' expression 
	  {
		$$ = new Conditional ((Expression) $1, (Expression) $3, (Expression) $5);
	  }
	;

assignment_expression
	: unary_expression '=' expression
	  {
		$$ = new Assign ((Expression) $1, (Expression) $3);
	  }
	| unary_expression '*=' expression
	  {
		$$ = new Assign ((Expression) $1,
				 new Binary (Binary.Operator.Multiply, 
					     (Expression) $1,
					     (Expression) $3));
	  }
	| unary_expression '/=' expression
	  {
		$$ = new Assign ((Expression) $1,
				 new Binary (Binary.Operator.Divide, 
					     (Expression) $1,
					     (Expression) $3));
	  }
	| unary_expression '%=' expression
	  {
		$$ = new Assign ((Expression) $1,
				 new Binary (Binary.Operator.Modulo, 
					     (Expression) $1,
					     (Expression) $3));
	  }
	| unary_expression '+=' expression
	  {
		$$ = new Assign ((Expression) $1,
				 new Binary (Binary.Operator.Add, 
					     (Expression) $1,
					     (Expression) $3));
	  }
	| unary_expression '-=' expression
	  {
		$$ = new Assign ((Expression) $1,
				 new Binary (Binary.Operator.Substract, 
					     (Expression) $1,
					     (Expression) $3));
	  }
	| unary_expression '<<=' expression
	  {
		$$ = new Assign ((Expression) $1,
				 new Binary (Binary.Operator.ShiftLeft, 
					     (Expression) $1,
					     (Expression) $3));
	  }
	| unary_expression '>>=' expression
	  {
		$$ = new Assign ((Expression) $1,
				 new Binary (Binary.Operator.ShiftRight, 
					     (Expression) $1,
					     (Expression) $3));
	  }
	| unary_expression '&=' expression
	  {
		$$ = new Assign ((Expression) $1,
				 new Binary (Binary.Operator.BitwiseAnd, 
					     (Expression) $1,
					     (Expression) $3));
	  }
	| unary_expression '|=' expression
	  {
		$$ = new Assign ((Expression) $1,
				 new Binary (Binary.Operator.BitwiseOr, 
					     (Expression) $1,
					     (Expression) $3));
	  }
	| unary_expression '^=' expression
	  {
		$$ = new Assign ((Expression) $1,
				 new Binary (Binary.Operator.ExclusiveOr, 
					     (Expression) $1,
					     (Expression) $3));
	  }
	;

expression
	: conditional_expression
	| assignment_expression
	;

constant_expression
	: expression
	;

boolean_expression
	: expression	{ CheckBoolean ((Expression) $1); $$ = $1; } 
	;

#
# 10 classes
#
class_declaration
	: opt_attributes
	  opt_modifiers
	  CLASS IDENTIFIER
	  {
		Class new_class;
		string full_class_name = MakeName ((string) $4);

		new_class = new Class (current_container, full_class_name, (int) $2);
		current_container = new_class;
		current_container.Namespace = current_namespace;
		tree.RecordType (full_class_name, new_class);
	  }
	  opt_class_base
	  class_body 
	  opt_semicolon 
	  {
		Class new_class = (Class) current_container;

		if ($6 != null)
			new_class.Bases = (ArrayList) $6;

		current_container = current_container.Parent;
		CheckDef (current_container.AddClass (new_class), new_class.Name);

		$$ = new_class;
	  }
	;	

opt_modifiers
	: /* empty */		{ $$ = (int) 0; }
	| modifiers
	;

modifiers
	: modifier
	| modifiers modifier	{ 
		int m1 = (int) $1;
		int m2 = (int) $2;

		if ((m1 & m2) != 0)
			error (1002, "Duplicate modifier: `" + Modifiers.Name (m2) + "'");

		$$ = (int) (m1 | m2);
	  }
	;

modifier
	: NEW			{ $$ = Modifiers.NEW; }
	| PUBLIC		{ $$ = Modifiers.PUBLIC; }
	| PROTECTED		{ $$ = Modifiers.PROTECTED; }
	| INTERNAL		{ $$ = Modifiers.INTERNAL; }
	| PRIVATE		{ $$ = Modifiers.PRIVATE; }
	| ABSTRACT		{ $$ = Modifiers.ABSTRACT; }
	| SEALED		{ $$ = Modifiers.SEALED; }
	| STATIC		{ $$ = Modifiers.STATIC; }
	| READONLY		{ $$ = Modifiers.READONLY; }
	| VIRTUAL		{ $$ = Modifiers.VIRTUAL; }
	| OVERRIDE 		{ $$ = Modifiers.OVERRIDE; }
	| EXTERN		{ $$ = Modifiers.EXTERN; }
	;

opt_class_base
	: /* empty */		{ $$ = null; }
	| class_base		{ $$ = $1; }
	;

class_base
	: ':' type_list { $$ = $2; }
	;

#
# Statements (8.2)
#

#
# A block is "contained" on the following places:
#	method_body
#	property_declaration as part of the accessor body (get/set)
#      operator_declaration
#	constructor_declaration
#	destructor_declaration
#	event_declaration as part of add_accessor_declaration or remove_accessor_declaration
#      
block
	: '{' 
	  {
		current_block = new Block (current_block);
	  } 
	  opt_statement_list '}' 
	  { 
		while (current_block.Implicit)
			current_block = current_block.Parent;
		$$ = current_block;
		current_block = current_block.Parent;
	  }
	;

opt_statement_list
	: /* empty */
	| statement_list 
	;

statement_list
	: statement
	| statement_list statement
	;

statement
	: declaration_statement
	  {
		if ((Block) $1 != current_block){
			current_block.AddStatement ((Statement) $1);
			current_block = (Block) $1;
		}
	  }
	| embedded_statement
	  {
		current_block.AddStatement ((Statement) $1);
	  }
	| labeled_statement 
	  {
		current_block.AddStatement ((Statement) $1);
	  }
	;

embedded_statement
	: block
	| empty_statement
        | expression_statement
	| selection_statement
	| iteration_statement
	| jump_statement		  
	| try_statement
	| checked_statement
	| unchecked_statement
	| lock_statement
	| using_statement
	;

empty_statement
	: ';'
	  {
		  $$ = new EmptyStatement ();
	  }
	;

labeled_statement
	: IDENTIFIER ':' statement
	  {
		string lab = (String) $1;
		Block block;

		block = new Block (current_block, lab);
		block.AddStatement ((Statement) $3);
		$$ = block;

		if (!current_block.AddLabel (lab, block)){
			error (140, "The label '" + lab + "' is a duplicate");
			$$ = $3;
		}	
	  }
	;

declaration_statement
	: local_variable_declaration ';'		# done
	| local_constant_declaration ';'		# finishme
	;

/* 
 * The following is from Rhys' grammar:
 * > Types in local variable declarations must be recognized as 
 * > expressions to prevent reduce/reduce errors in the grammar.
 * > The expressions are converted into types during semantic analysis.
 */
local_variable_type
	: primary_expression type_suffixes
	  { 
		# FIXME: Do something smart here regarding the composition of the type.
		#

		# Ok, the above "primary_expression" is there to get rid of
		# both reduce/reduce and shift/reduces in the grammar, it should
		# really just be "type_name".  If you use type_name, a reduce/reduce
		# creeps up.  If you use qualified_identifier (which is all we need
		# really) two shift/reduces appear.
		# 
		# So, instead we do a super trick: we just allow ($1) to be a 
		# SimpleName Expression.
		#
		if (((Expression) $1) is SimpleName)
			$$ = type (((SimpleName) $1).Name);
		else {
			error (-1, "Invalid Type definition");
			$$ = type ("object");
		}
	  }
	| builtin_types type_suffixes
	  {
		# FIXME: Do something smart with the type here.
		$$ = $1; 
	  }
	| VOID type_suffixes
	  {
		$$ = type ("VOID SOMETHING TYPE");
	  }
	;

type_suffixes
	: /* empty */
	| type_suffix_list
	;

type_suffix_list 
	: type_suffix
	| type_suffix_list type_suffix
	;

type_suffix
	: '[' opt_dim_separators ']'
	/* FIXME: | MULTIPLY */
	;

local_variable_declaration
	: local_variable_type variable_declarators
	  {
		$$ = declare_local_variables ((TypeRef) $1, (ArrayList) $2);
	  }
	;

local_constant_declaration
	: CONST type constant_declarator
	 	# finishme	
	;

expression_statement
	: statement_expression ';'
	  {
		$$ = $1;
	  }
	;

	#
	# We have to do the wrapping here and not in the case above,
	# because statement_expression is used for example in for_statement
	#
statement_expression
	: invocation_expression		{ $$ = new StatementExpression ((Expression) $1); }
	| object_creation_expression	{ $$ = new StatementExpression ((Expression) $1); }
	| assignment_expression		{ $$ = new StatementExpression ((Expression) $1); }
	| post_increment_expression	{ $$ = new StatementExpression ((Expression) $1); }
	| post_decrement_expression	{ $$ = new StatementExpression ((Expression) $1); }
	| pre_increment_expression	{ $$ = new StatementExpression ((Expression) $1); }
	| pre_decrement_expression	{ $$ = new StatementExpression ((Expression) $1); }
	;

object_creation_expression
	: object_or_delegate_creation_expression
	  { note ("complain if this is a delegate maybe?"); } 
	;

selection_statement
	: if_statement
	| switch_statement
	; 

if_statement
	: IF '(' boolean_expression ')' 
	  embedded_statement
	  { 
		$$ = new If ((Expression) $3, (Statement) $5);
	  }
	| IF '(' boolean_expression ')'
	  embedded_statement ELSE embedded_statement
	  {
		$$ = new If ((Expression) $3, (Statement) $5, (Statement) $7);
	  }
	;

switch_statement
	: SWITCH '(' expression ')' 
	  switch_block
	  {
		$$ = new Switch ((Expression) $3, (ArrayList) $5);
	  }
	;

switch_block
	: '{'
	  opt_switch_sections
	  '}'
	  {
		$$ = $2;
	  }
	;

opt_switch_sections
	: /* empty */ 		{ $$ = new ArrayList (); }
	| switch_sections
	;

switch_sections
	: switch_section 
	  {
		ArrayList sections = new ArrayList ();

		sections.Add ($1);
		$$ = sections;
	  }
	| switch_sections switch_section
	  {
		ArrayList sections = (ArrayList) $1;

		sections.Add ($2);
		$$ = sections;
	  }
	;

switch_section
	: switch_labels
	  {
		current_block = new Block (current_block);
	  }
 	  statement_list 
	  {
		while (current_block.Implicit)
			current_block = current_block.Parent;
		$$ = new SwitchSection ((ArrayList) $1, current_block);
		current_block = current_block.Parent;
	  }
	;

switch_labels
	: switch_label 
	  {
		ArrayList labels = new ArrayList ();

		labels.Add ($1);
		$$ = labels;
	  }
	| switch_labels switch_label 
	  {
		ArrayList labels = (ArrayList) ($1);
		labels.Add ($2);

		$$ = labels;
	  }
	;

switch_label
	: CASE constant_expression ':' 	{ $$ = new SwitchLabel ((Expression) $2); }
	| DEFAULT ':'				{ $$ = new SwitchLabel (null); }
	;

iteration_statement
	: while_statement
	| do_statement
	| for_statement
	| foreach_statement
	;

while_statement
	: WHILE '(' boolean_expression ')' embedded_statement
	{
		$$ = new While ((Expression) $3, (Statement) $5);
	}
	;

do_statement
	: DO embedded_statement 
	  WHILE '(' boolean_expression ')' ';'
	  {
		$$ = new Do ((Statement) $2, (Expression) $5);
	  }
	;

for_statement
	: FOR '(' 
	  opt_for_initializer ';'
	  opt_for_condition ';'
	  opt_for_iterator ')' 
	  embedded_statement
	  {
		$$ = new For ((Statement) $3, (Expression) $5, (Statement) $7, (Statement) $9);
	  }
	;

opt_for_initializer
	: /* empty */		{ $$ = new EmptyStatement (); }
	| for_initializer	
	;

for_initializer
	: local_variable_declaration
	| statement_expression_list
	;

opt_for_condition
	: /* empty */		{ $$ = new BoolLiteral (true); }
	| boolean_expression
	;

opt_for_iterator
	: /* empty */		{ $$ = new EmptyStatement (); }
	| for_iterator
	;

for_iterator
	: statement_expression_list
	;

statement_expression_list
	: statement_expression	
	  {
		Block b = new Block (null, true);

		b.AddStatement ((Statement) $1);
		$$ = b;
	  }
	| statement_expression_list ',' statement_expression
	  {
		Block b = (Block) $1;

		b.AddStatement ((Statement) $3);
		$$ = $1;
	  }
	;

foreach_statement
	: FOREACH '(' type IDENTIFIER IN expression ')' 
	  embedded_statement
	  {
		string temp_id = current_block.MakeInternalID ();
		Expression assign_e, ma;
		Statement getcurrent;
		Block foreach_block, child_block;

		foreach_block = new Block (current_block, true);

		foreach_block.AddVariable (type ("IEnumerator"), temp_id);
		foreach_block.AddVariable ((TypeRef) $3, (string) $4);
		assign_e = new Assign (new LocalVariableReference (foreach_block, temp_id), 
				       new Invocation (
						new MemberAccess ((Expression) $6, "GetEnumerator"), null));
		current_block.AddStatement (new StatementExpression (assign_e));
		ma = new MemberAccess (new LocalVariableReference (foreach_block, temp_id), "MoveNext");
		child_block = new Block (current_block);

		getcurrent = new StatementExpression (
			new Assign (
				new LocalVariableReference (foreach_block, (string) $4),
				new Cast (
					(TypeRef) $3, 
					new MemberAccess (
						new LocalVariableReference (foreach_block, temp_id), "Current"))));

		child_block.AddStatement (getcurrent);
		child_block.AddStatement ((Statement) $8);
	 	foreach_block.AddStatement (new While (ma, (Statement) child_block));

		$$ = foreach_block;
	  }
	;

jump_statement
	: break_statement
	| continue_statement
	| goto_statement
	| return_statement
	| throw_statement
	;

break_statement
	: BREAK ';'
	  {
		$$ = new Break ();
	  }
	;

continue_statement
	: CONTINUE ';'
	  {
		$$ = new Continue ();
	  }
	;

goto_statement
	: GOTO IDENTIFIER ';' 
	  {
		$$ = new Goto ((string) $2);
	  }
	| GOTO CASE constant_expression ';'
	| GOTO DEFAULT ';' 
	; 

return_statement
	: RETURN opt_expression ';'
	  {
		$$ = new Return ((Expression) $2);
	  }
	;

throw_statement
	: THROW opt_expression ';'
	  {
		$$ = new Throw ((Expression) $2);
	  }
	;

opt_expression
	: /* empty */
	| expression
	;

try_statement
	: TRY block catch_clauses 
	  {
		DictionaryEntry cc = (DictionaryEntry) $3;
		ArrayList s = null;

		if (cc.Key != null)
			s = (ArrayList) cc.Key;

		$$ = new Try ((Block) $2, s, (Catch) cc.Value, null);
	  }
	| TRY block finalize_clause 
	  {
		$$ = new Try ((Block) $2, null, null, (Block) $3);
	  }
	| TRY block catch_clauses finalize_clause
	  {
		DictionaryEntry cc = (DictionaryEntry) $3;
		ArrayList s = null;

		if (cc.Key != null)
			s = (ArrayList) cc.Key;

		$$ = new Try ((Block) $2, s, (Catch) cc.Value, (Block) $4);
	  }
	;

catch_clauses
	: specific_catch_clauses opt_general_catch_clause
	  {
		DictionaryEntry pair = new DictionaryEntry ();

		pair.Key = $1; 
		pair.Value = $2;

		$$ = pair;
	  }
	| opt_specific_catch_clauses general_catch_clause
	  {
		DictionaryEntry pair = new DictionaryEntry ();
		pair.Key = $1;
		pair.Value = $1;

		$$ = pair;
	  }
	;

opt_general_catch_clause
	: /* empty */			{ $$ = null; }
	| general_catch_clause 
	;

opt_specific_catch_clauses
	: /* emtpy */			{ $$ = null; }
	| specific_catch_clauses 
	;

specific_catch_clauses
	: specific_catch_clause 
	  {
		ArrayList l = new ArrayList ();

		l.Add ($1);
		$$ = l;
	  }
	| specific_catch_clauses specific_catch_clause
	  {
		ArrayList l = (ArrayList) $1;

		l.Add ($2);
		$$ = l;
	  }
	;

specific_catch_clause
	: CATCH '(' type opt_identifier ')' block
	  {
		string id = null;

		if ($4 != null)
			id = (string) $4;

		$$ = new Catch ((TypeRef) $3, id, (Block) $6);
	  }
	;

opt_identifier
	: /* empty */	{ $$ = null; }
	| IDENTIFIER
	;

general_catch_clause
	: CATCH block
	  {
		$$ = new Catch (null, null, (Block) $2);
	  }
	;

finalize_clause
	: FINALLY block
	  {
		$$ = $2;
	  }
	;

checked_statement
	: CHECKED block
	  {
		$$ = new Checked ((Block) $2);
	  }
	;

unchecked_statement
	: UNCHECKED block
	  {
		$$ = new Unchecked ((Block) $2);
	  }
	;

lock_statement
	: LOCK '(' expression ')' embedded_statement
	  {
		$$ = new Lock ((Expression) $3, (Statement) $5);
	  }
	;

using_statement
	: USING '(' resource_acquisition ')' embedded_statement
	  # finishme
	; 

resource_acquisition
	: local_variable_declaration
	  expression
	  # finishme
	;

%%

# <summary>
#   A class used to pass around variable declarations and constants
# </summary>
public class VariableDeclaration {
	public string identifier;
	public object expression_or_array_initializer;

	public VariableDeclaration (string id, object eoai){
		this.identifier = id;
		this.expression_or_array_initializer = eoai;
	}
}

# <summary>
#   Given the @class_name name, it creates a fully qualified name
#   based on the containing declaration space
# </summary>
string 
MakeName (string class_name)
{
	string ns = current_namespace.Name;
	string container_name = current_container.Name;

	if (container_name == ""){
		if (ns != "")
			return ns + "." + class_name;
		else
			return class_name;
	} else
		return container_name + "." + class_name;
}

# <summary>
#   Used to report back to the user the result of a declaration
#   in the current declaration space
# </summary>
void 
CheckDef (DeclSpace.AdditionResult result, string name)
{
	if (result == DeclSpace.AdditionResult.Success)
		return;

	switch (result){
	case DeclSpace.AdditionResult.NameExists:
		error (102, "The namespace `" + current_container.Name + 
			    "' already contains a definition for `"+
			    name + "'");
		break;

/*
	NEED TO HANDLE THIS IN SEMANTIC ANALYSIS:

	case DeclSpace.AdditionResult.MethodDuplicated:
		error (111, "Class `"+current_container.Name+
			    "' already defines a member called '" + 
			    name + "' with the same parameter types");
		break;
*/
	case DeclSpace.AdditionResult.EnclosingClash:
		error (542, "Member names cannot be the same as their enclosing type");
		break;

	case DeclSpace.AdditionResult.NotAConstructor:
		error (1520, "Class, struct, or interface method must have a return type");
		break;
	}
}

void 
CheckDef (bool result, string name)
{
	if (result)
		return;
	CheckDef (DeclSpace.AdditionResult.NameExists, name);
}

Block declare_local_variables (TypeRef typeref, ArrayList variable_declarators)
{
	Block implicit_block;
	ArrayList inits = null;

	#
	# We use the `Used' property to check whether statements
	# have been added to the current block.  If so, we need
	# to create another block to contain the new declaration
	# otherwise, as an optimization, we use the same block to
	# add the declaration.
	#
	# FIXME: A further optimization is to check if the statements
	# that were added were added as part of the initialization
	# below.  In which case, no other statements have been executed
	# and we might be able to reduce the number of blocks for
	# situations like this:
	#
	# int j = 1;  int k = j + 1;
	#
	if (current_block.Used)
		implicit_block = new Block (current_block, true);
	else
		implicit_block = new Block (current_block, true);

	foreach (VariableDeclaration decl in variable_declarators){
		if (implicit_block.AddVariable (typeref, decl.identifier)){
			if (decl.expression_or_array_initializer != null){
				if (inits == null)
					inits = new ArrayList ();
				inits.Add (decl);
			}
		} else {
			error (128, "A local variable `" + decl.identifier +
				    "' is already defined in this scope");
		}
	}

	if (inits == null)
		return implicit_block;

	foreach (VariableDeclaration decl in inits){
		if (decl.expression_or_array_initializer is Expression){
			Expression expr = (Expression) decl.expression_or_array_initializer;
			Assign assign;
			
			assign = new Assign (new LocalVariableReference (implicit_block, decl.identifier), expr);
			implicit_block.AddStatement (new StatementExpression (assign));
		} else {
		}
	}
			
	return implicit_block;
}

void CheckConstant (Expression expr)
{
	# finishme
}

void CheckBoolean (Expression expr)
{
	# finishme
}

static public void error (int code, string desc)
{
	Console.WriteLine ("Error CS"+code+": "+desc);
	global_errors++;
}

void output (string s)
{
	Console.WriteLine (s);
}

void note (string s)
{
	# Used to put annotations
}

TypeRef type (string type_name)
{
	return type_references.GetTypeRef (current_container, type_name);
}

Tokenizer lexer;

public CSharpParser(CIR.Tree tree, string name, System.IO.Stream input) 
	: base (tree, name, input)
{
	current_namespace = new Namespace (null, "");
	this.tree = tree;
	current_container = tree.Types;
	current_container.Namespace = current_namespace;

	lexer = new Tokenizer (input, name);
	type_references = tree.TypeRefManager; 
}

public override int parse ()
{
	StringBuilder value = new StringBuilder ();

	global_errors = 0;
	try {
		if (yacc_verbose_flag)
			yyparse (lexer, new yydebug.yyDebugSimple ());
		else
			yyparse (lexer);
	} catch (Exception e){
		Console.WriteLine ("Fatal error: "+name);
		Console.WriteLine (e);
		Console.WriteLine (lexer.location);
		global_errors++;
	}
	
	return global_errors;
}

bool yacc_verbose_flag = false;

public bool yacc_verbose {
	set {
		yacc_verbose_flag = value;
	}

	get {
		return yacc_verbose_flag;
	}
}

/* end end end */
}
}

